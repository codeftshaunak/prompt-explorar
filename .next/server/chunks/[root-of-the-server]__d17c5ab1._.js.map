{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 67, "column": 0}, "map": {"version":3,"sources":["file:///Users/hypomatrix/Desktop/new-projects/prompt-explorer/src/app/api/categories/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\nimport fs from 'fs'\nimport path from 'path'\nimport matter from 'gray-matter'\n\nexport interface PromptCategory {\n  name: string\n  count: number\n  description?: string\n}\n\nconst PROMPTS_DIR = path.join(process.cwd(), 'data', 'prompts')\n\nfunction getAllPrompts() {\n  const prompts: Array<{ category: string }> = []\n\n  function scanDirectory(dir: string, category: string = '') {\n    try {\n      const items = fs.readdirSync(dir)\n\n      for (const item of items) {\n        const fullPath = path.join(dir, item)\n        const stat = fs.statSync(fullPath)\n\n        if (stat.isDirectory() && !item.startsWith('.') && item !== 'node_modules' && item !== 'prompt-explorer') {\n          const categoryName = category ? `${category}/${item}` : item\n          scanDirectory(fullPath, categoryName)\n        } else if (item.endsWith('.txt') || item.endsWith('.md')) {\n          try {\n            const finalCategory = category || path.basename(path.dirname(fullPath))\n            prompts.push({ category: finalCategory })\n          } catch (error) {\n            console.warn(`Error reading file ${fullPath}:`, error)\n          }\n        }\n      }\n    } catch (error) {\n      console.warn(`Error scanning directory ${dir}:`, error)\n    }\n  }\n\n  scanDirectory(PROMPTS_DIR)\n  return prompts\n}\n\nexport async function GET() {\n  try {\n    const prompts = getAllPrompts()\n    const categoryMap = new Map<string, number>()\n\n    prompts.forEach(prompt => {\n      categoryMap.set(prompt.category, (categoryMap.get(prompt.category) || 0) + 1)\n    })\n\n    const categories: PromptCategory[] = Array.from(categoryMap.entries())\n      .map(([name, count]) => ({ name, count }))\n      .sort((a, b) => b.count - a.count)\n\n    return NextResponse.json(categories)\n  } catch (error) {\n    console.error('Error fetching categories:', error)\n    return NextResponse.json({ error: 'Failed to fetch categories' }, { status: 500 })\n  }\n}"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AASA,MAAM,cAAc,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,QAAQ;AAErD,SAAS;IACP,MAAM,UAAuC,EAAE;IAE/C,SAAS,cAAc,GAAW,EAAE,WAAmB,EAAE;QACvD,IAAI;YACF,MAAM,QAAQ,wGAAE,CAAC,WAAW,CAAC;YAE7B,KAAK,MAAM,QAAQ,MAAO;gBACxB,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,KAAK;gBAChC,MAAM,OAAO,wGAAE,CAAC,QAAQ,CAAC;gBAEzB,IAAI,KAAK,WAAW,MAAM,CAAC,KAAK,UAAU,CAAC,QAAQ,SAAS,kBAAkB,SAAS,mBAAmB;oBACxG,MAAM,eAAe,WAAW,GAAG,SAAS,CAAC,EAAE,MAAM,GAAG;oBACxD,cAAc,UAAU;gBAC1B,OAAO,IAAI,KAAK,QAAQ,CAAC,WAAW,KAAK,QAAQ,CAAC,QAAQ;oBACxD,IAAI;wBACF,MAAM,gBAAgB,YAAY,4GAAI,CAAC,QAAQ,CAAC,4GAAI,CAAC,OAAO,CAAC;wBAC7D,QAAQ,IAAI,CAAC;4BAAE,UAAU;wBAAc;oBACzC,EAAE,OAAO,OAAO;wBACd,QAAQ,IAAI,CAAC,CAAC,mBAAmB,EAAE,SAAS,CAAC,CAAC,EAAE;oBAClD;gBACF;YACF;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,IAAI,CAAC,CAAC,yBAAyB,EAAE,IAAI,CAAC,CAAC,EAAE;QACnD;IACF;IAEA,cAAc;IACd,OAAO;AACT;AAEO,eAAe;IACpB,IAAI;QACF,MAAM,UAAU;QAChB,MAAM,cAAc,IAAI;QAExB,QAAQ,OAAO,CAAC,CAAA;YACd,YAAY,GAAG,CAAC,OAAO,QAAQ,EAAE,CAAC,YAAY,GAAG,CAAC,OAAO,QAAQ,KAAK,CAAC,IAAI;QAC7E;QAEA,MAAM,aAA+B,MAAM,IAAI,CAAC,YAAY,OAAO,IAChE,GAAG,CAAC,CAAC,CAAC,MAAM,MAAM,GAAK,CAAC;gBAAE;gBAAM;YAAM,CAAC,GACvC,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,KAAK,GAAG,EAAE,KAAK;QAEnC,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,8BAA8B;QAC5C,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAA6B,GAAG;YAAE,QAAQ;QAAI;IAClF;AACF","debugId":null}}]
}